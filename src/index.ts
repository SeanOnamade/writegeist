import { app, BrowserWindow, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'node:path';
import fs from 'node:fs';
import os from 'node:os';
const http = require('node:http');
const https = require('node:https');
import { URL } from 'node:url';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Track the API backend process
let apiProcess: any;

// Track the webhook server
let webhookServer: any;

// Config management
const getConfigPath = () => {
  const configDir = path.join(os.homedir(), 'AppData', 'Roaming', 'Writegeist');
  const configFile = path.join(configDir, 'config.json');
  return { configDir, configFile };
};

const loadConfig = () => {
  const { configFile } = getConfigPath();
  try {
    if (fs.existsSync(configFile)) {
      return JSON.parse(fs.readFileSync(configFile, 'utf8'));
    }
  } catch (error) {
    console.error('Error loading config:', error);
  }
  return { OPENAI_API_KEY: '', PORT: 8000 };
};

const saveConfig = (config: any) => {
  const { configDir, configFile } = getConfigPath();
  try {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error('Error saving config:', error);
    return false;
  }
};

const restartApiBackend = () => {
  if (apiProcess) {
    console.log('Restarting API backend...');
    apiProcess.kill();
    apiProcess = null;
    
    // Wait a moment then restart
    setTimeout(() => {
      startApiBackend();
    }, 1000);
  }
};

const startApiBackend = () => {
  const config = loadConfig();
  const exePath = app.isPackaged
    ? path.join(process.resourcesPath, 'writegeist-api.exe')
    : path.join(process.cwd(), 'resources', 'writegeist-api.exe');

  // In development, use batch script that activates venv and runs uvicorn
  const usePythonSource = !app.isPackaged;
  const batchScriptPath = path.join(process.cwd(), 'ai-service', 'start_api.bat');
  const command = usePythonSource ? batchScriptPath : exePath;
  const args = usePythonSource ? [] : [];
  const cwd = usePythonSource ? undefined : undefined;

  console.log('Starting API backend from:', usePythonSource ? 'batch script (venv)' : exePath);
  
  try {
    apiProcess = spawn(command, args, { 
      stdio: 'inherit',
      cwd: cwd,
      shell: true,
      env: { 
        ...process.env, 
        WG_PORT: config.PORT || '8000',
        OPENAI_API_KEY: config.OPENAI_API_KEY || ''
      }
    });
    
    apiProcess.on('error', (error: Error) => {
      console.error('Failed to start API backend:', error);
    });
    
    apiProcess.on('exit', (code: number) => {
      console.log('API backend exited with code:', code);
    });
    
    console.log('API backend started with PID:', apiProcess.pid);
  } catch (error) {
    console.error('Error spawning API backend:', error);
  }
};

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Configure CSP to allow localhost connections
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' http://127.0.0.1:8000 http://localhost:8000 http://localhost:3001 https://n8n-writegeist-u50080.vm.elestio.app https://python-fastapi-u50080.vm.elestio.app; script-src 'self' 'unsafe-inline' 'unsafe-eval';"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();

  // Start database monitoring
  const dbPath = path.join(process.cwd(), 'writegeist.db');
  startDbMonitoring(dbPath, mainWindow);
  
  // Set webhook reference for database sync events
  webhookMainWindow = mainWindow;
  
  // Start webhook listener for external notifications
  startWebhookListener(mainWindow);
};

// Database change monitoring
let dbWatcher: fs.FSWatcher | null = null;
let lastDbModified: number = 0;

const startDbMonitoring = (dbPath: string, mainWindow: BrowserWindow) => {
  try {
    // Stop existing watcher
    if (dbWatcher) {
      dbWatcher.close();
    }

    // Get initial modification time
    const stats = fs.statSync(dbPath);
    lastDbModified = stats.mtimeMs;

    // Watch for file changes
    dbWatcher = fs.watch(dbPath, (eventType) => {
      if (eventType === 'change') {
        try {
          const newStats = fs.statSync(dbPath);
          if (newStats.mtimeMs > lastDbModified) {
            lastDbModified = newStats.mtimeMs;
            
            // Notify renderer about database changes
            mainWindow.webContents.send('db-updated', {
              table: 'unknown', // We can't determine specific table from file watch
              updatedAt: new Date().toISOString()
            });
          }
        } catch (error) {
          console.warn('Error checking database modification:', error);
        }
      }
    });

    console.log('Database monitoring started');
  } catch (error) {
    console.warn('Failed to start database monitoring:', error);
  }
};

// Webhook server for n8n to trigger database syncing
let webhookMainWindow: BrowserWindow | null = null;

// Webhook listener for external notifications from n8n
const startWebhookListener = (mainWindow: BrowserWindow) => {
  let lastNotificationCheck = Date.now();
  
  const syncFromVM = async () => {
    if (!mainWindow || mainWindow.isDestroyed()) return;
    
    try {
      console.log('Syncing from VM after webhook notification...');
      
      // Show loading state immediately
      mainWindow.webContents.send('sync-started', {
        message: 'Syncing latest changes...',
        timestamp: new Date().toISOString()
      });
      
      // Download and sync database from VM
      const https = require('https');
      const vmDbUrl = 'https://python-fastapi-u50080.vm.elestio.app/download-db';
      const tempDbPath = path.join(process.cwd(), 'writegeist_temp.db');
      const finalDbPath = path.join(process.cwd(), 'writegeist.db');
      
      const downloadDatabase = () => {
        return new Promise((resolve, reject) => {
          const fs = require('fs');
          const file = fs.createWriteStream(tempDbPath);
          https.get(vmDbUrl, (response) => {
            if (response.statusCode === 200) {
              response.pipe(file);
              file.on('finish', () => {
                file.close();
                resolve(true);
              });
            } else {
              reject(new Error(`Failed to download: ${response.statusCode}`));
            }
          }).on('error', reject);
        });
      };
      
      try {
        await downloadDatabase();
        
        // Replace the database file
        const fs = require('fs');
        if (fs.existsSync(finalDbPath)) {
          fs.unlinkSync(finalDbPath);
        }
        fs.renameSync(tempDbPath, finalDbPath);
        
        console.log('Database sync successful - triggering UI refresh');
        
        // Force UI refresh after successful sync
        mainWindow.webContents.send('sync-completed', {
          success: true,
          message: 'Content updated successfully',
          timestamp: new Date().toISOString()
        });
        
        // Also send the db-updated event for backward compatibility
        mainWindow.webContents.send('db-updated', {
          table: 'project_pages',
          updatedAt: new Date().toISOString()
        });
        
      } catch (syncError) {
        console.warn('Database file sync failed (likely locked), but forcing UI refresh anyway:', syncError.message);
        
        // Even if sync fails, force UI refresh since VM has newer content
        mainWindow.webContents.send('sync-completed', {
          success: false,
          message: 'Sync failed but VM has updates - please refresh manually or restart app',
          timestamp: new Date().toISOString(),
          forceRefresh: true
        });
        
        // Still send db-updated to trigger UI refresh attempt
        mainWindow.webContents.send('db-updated', {
          table: 'project_pages', 
          updatedAt: new Date().toISOString(),
          forceRefresh: true
        });
      }
      
    } catch (error) {
      console.warn('Complete sync failed:', error);
      
      // Hide loading and show error
      mainWindow.webContents.send('sync-completed', {
        success: false,
        message: 'Sync failed - VM may be unavailable',
        timestamp: new Date().toISOString()
      });
    }
  };
  
  const checkForWebhookNotifications = async () => {
    try {
      // Check VM's last-updated timestamp
      const https = require('https');
      const lastUpdatedUrl = 'https://python-fastapi-u50080.vm.elestio.app/last-updated';
      
      https.get(lastUpdatedUrl, (response) => {
        if (response.statusCode === 200) {
          let data = '';
          response.on('data', chunk => data += chunk);
          response.on('end', () => {
            try {
              const result = JSON.parse(data);
              const vmLastUpdated = parseInt(result.last_updated);
              
              // If VM was updated after our last check, sync immediately
              if (vmLastUpdated > (lastNotificationCheck / 1000)) {
                console.log(`VM database was updated at ${new Date(vmLastUpdated * 1000).toLocaleTimeString()}, syncing...`);
                lastNotificationCheck = Date.now();
                syncFromVM();
              }
            } catch (error) {
              // Ignore parsing errors
            }
          });
        }
      }).on('error', () => {
        // Ignore connection errors
      });
      
    } catch (error) {
      // Ignore errors - webhook system is optional
    }
  };
  
  // Check for webhook notifications every 5 seconds (faster polling)
  setInterval(checkForWebhookNotifications, 5000);
  
  // Initial sync after 3 seconds
  setTimeout(syncFromVM, 3000);
};

const startWebhookServer = () => {
  const PORT = 3001; // Use a different port from the main API
  
  webhookServer = http.createServer(async (req, res) => {
    // Log to file instead of console
    const logMessage = `ðŸŒ WEBHOOK SERVER RECEIVED REQUEST: ${req.method} ${req.url} at ${new Date().toISOString()}\n`;
    fs.appendFileSync(path.join(process.cwd(), 'webhook.log'), logMessage);
    
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }
    
    const url = new URL(req.url!, `http://localhost:${PORT}`);
    
    if (req.method === 'POST' && url.pathname === '/sync-database') {
      const tempDbPath = path.join(process.cwd(), 'writegeist_temp.db');
      const finalDbPath = path.join(process.cwd(), 'writegeist.db');
      
      // Log to file for debugging
      const logSync = (message) => {
        fs.appendFileSync(path.join(process.cwd(), 'webhook.log'), `${message}\n`);
      };
      
      logSync('ðŸ”„ SYNC DATABASE REQUEST RECEIVED');
      logSync(`ðŸ“ Temp DB Path: ${tempDbPath}`);
      logSync(`ðŸ“ Final DB Path: ${finalDbPath}`);
      
      try {
        // 1. PRE-FLIGHT CHECKS
        console.log('ðŸ” Running pre-flight checks...');
        
        // Check if temp file already exists and clean it
        if (fs.existsSync(tempDbPath)) {
          console.log('âš ï¸  Temp file exists, removing it...');
          try {
            fs.unlinkSync(tempDbPath);
            console.log('âœ… Temp file removed');
          } catch (err) {
            console.error('âŒ Failed to remove existing temp file:', err);
            throw new Error(`Failed to remove existing temp file: ${err.message}`);
          }
        }
        
        // Check disk space (basic check - try to create a test file)
        try {
          const testFilePath = path.join(process.cwd(), 'test_write.tmp');
          fs.writeFileSync(testFilePath, 'test');
          fs.unlinkSync(testFilePath);
          console.log('âœ… Disk write test passed');
        } catch (err) {
          console.error('âŒ Disk write test failed:', err);
          throw new Error(`Disk write test failed: ${err.message}`);
        }
        
        // Check if database file is currently locked
        try {
          const stats = fs.statSync(finalDbPath);
          console.log('ðŸ“Š Current DB file size:', stats.size, 'bytes');
          console.log('ðŸ“Š Current DB modified:', stats.mtime.toISOString());
        } catch (err) {
          console.log('âš ï¸  No existing database file found');
        }
        
        // 2. NETWORK CONNECTIVITY CHECK
        console.log('ðŸŒ Testing VM connectivity...');
        const vmDbUrl = 'https://python-fastapi-u50080.vm.elestio.app/download-db';
        
        const testVmConnection = () => {
          return new Promise((resolve, reject) => {
            const testReq = https.request(vmDbUrl, { method: 'HEAD', timeout: 10000 }, (response) => {
              console.log('ðŸŒ VM connectivity test - Status:', response.statusCode);
              if (response.statusCode === 200) {
                resolve(true);
              } else {
                reject(new Error(`VM connectivity test failed: ${response.statusCode}`));
              }
            });
            
            testReq.on('error', (err) => {
              console.error('âŒ VM connectivity test error:', err);
              reject(err);
            });
            
            testReq.on('timeout', () => {
              console.error('â±ï¸  VM connectivity test timeout');
              testReq.destroy();
              reject(new Error('VM connectivity test timeout'));
            });
            
            testReq.end();
          });
        };
        
        await testVmConnection();
        console.log('âœ… VM connectivity test passed');
        
        // 3. DOWNLOAD DATABASE WITH COMPREHENSIVE ERROR HANDLING
        console.log('â¬‡ï¸  Starting database download...');
        
        const downloadDatabase = () => {
          return new Promise((resolve, reject) => {
            const file = fs.createWriteStream(tempDbPath);
            let downloadedBytes = 0;
            
            // File stream error handling
            file.on('error', (err) => {
              console.error('âŒ File write error:', err);
              reject(new Error(`File write error: ${err.message}`));
            });
            
            // Create HTTPS request with timeout
            const request = https.get(vmDbUrl, { timeout: 30000 }, (response) => {
              console.log('ðŸ“¡ Download response status:', response.statusCode);
              console.log('ðŸ“¡ Download response headers:', response.headers);
              
              if (response.statusCode === 200) {
                const totalSize = parseInt(response.headers['content-length'] || '0');
                console.log('ðŸ“Š Expected download size:', totalSize, 'bytes');
                
                // Track download progress
                response.on('data', (chunk) => {
                  downloadedBytes += chunk.length;
                  if (totalSize > 0) {
                    const progress = ((downloadedBytes / totalSize) * 100).toFixed(1);
                    console.log(`ðŸ“Š Download progress: ${progress}% (${downloadedBytes}/${totalSize} bytes)`);
                  }
                });
                
                response.pipe(file);
                
                file.on('finish', () => {
                  console.log('âœ… Download stream finished');
                  file.close((err) => {
                    if (err) {
                      console.error('âŒ File close error:', err);
                      reject(new Error(`File close error: ${err.message}`));
                    } else {
                      // Verify file was created and has content
                      try {
                        const stats = fs.statSync(tempDbPath);
                        console.log('ðŸ“Š Downloaded file size:', stats.size, 'bytes');
                        if (stats.size === 0) {
                          reject(new Error('Downloaded file is empty'));
                        } else {
                          console.log('âœ… Download completed successfully');
                          resolve(true);
                        }
                      } catch (statErr) {
                        console.error('âŒ Failed to verify downloaded file:', statErr);
                        reject(new Error(`Failed to verify downloaded file: ${statErr.message}`));
                      }
                    }
                  });
                });
              } else {
                console.error('âŒ Download failed with status:', response.statusCode);
                file.destroy();
                reject(new Error(`Download failed: ${response.statusCode} - ${response.statusMessage}`));
              }
            });
            
            // Request timeout handling
            request.on('timeout', () => {
              console.error('â±ï¸  Download request timeout');
              file.destroy();
              request.destroy();
              reject(new Error('Download request timeout'));
            });
            
            // Request error handling
            request.on('error', (err) => {
              console.error('âŒ HTTPS request error:', err);
              file.destroy();
              reject(new Error(`HTTPS request error: ${err.message}`));
            });
            
            // Start the request
            request.end();
          });
        };
        
        // Download with timeout wrapper
        const downloadWithTimeout = () => {
          return Promise.race([
            downloadDatabase(),
            new Promise((_, reject) => {
              setTimeout(() => {
                reject(new Error('Download operation timeout (45 seconds)'));
              }, 45000);
            })
          ]);
        };
        
        await downloadWithTimeout();
        console.log('âœ… Database downloaded successfully');
        
        // 4. SAFE FILE REPLACEMENT WITH DATABASE CONNECTION HANDLING
        logSync('ðŸ”„ Starting safe file replacement...');
        
        // Close database connections directly
        logSync('ðŸ“´ Closing database connections...');
        const { closeDatabaseConnection } = await import('./db');
        const closeResult = closeDatabaseConnection();
        logSync(`ðŸ“´ Database close result: ${closeResult}`);
        
        // Wait for database to close
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Create backup of current database
        const backupPath = path.join(process.cwd(), `writegeist_backup_${Date.now()}.db`);
        if (fs.existsSync(finalDbPath)) {
          try {
            fs.copyFileSync(finalDbPath, backupPath);
            logSync('âœ… Backup created: ' + backupPath);
          } catch (backupErr) {
            logSync('âš ï¸  Failed to create backup: ' + backupErr);
            // Continue anyway, but warn
          }
        }
        
        // Replace the current database file
        if (fs.existsSync(finalDbPath)) {
          try {
            // Try to remove the file (should work now that connections are closed)
            fs.unlinkSync(finalDbPath);
            logSync('âœ… Existing database file removed');
          } catch (removeErr) {
            logSync('âŒ Failed to remove existing database file: ' + removeErr);
            throw new Error(`Failed to remove existing database file: ${removeErr.message}`);
          }
        }
        
        try {
          fs.renameSync(tempDbPath, finalDbPath);
          logSync('âœ… Database file replaced successfully');
          
          // Verify the new file
          const newStats = fs.statSync(finalDbPath);
          logSync(`ðŸ“Š New DB file size: ${newStats.size} bytes`);
          logSync(`ðŸ“Š New DB modified: ${newStats.mtime.toISOString()}`);
          
          // Remove backup if everything worked
          if (fs.existsSync(backupPath)) {
            try {
              fs.unlinkSync(backupPath);
              logSync('âœ… Backup removed (operation successful)');
            } catch (backupCleanupErr) {
              logSync('âš ï¸  Failed to remove backup: ' + backupCleanupErr);
            }
          }
          
        } catch (renameErr) {
          logSync('âŒ Failed to replace database file: ' + renameErr);
          
          // Try to restore from backup
          if (fs.existsSync(backupPath)) {
            try {
              fs.renameSync(backupPath, finalDbPath);
              logSync('âœ… Restored from backup');
            } catch (restoreErr) {
              logSync('âŒ Failed to restore from backup: ' + restoreErr);
            }
          }
          
          throw new Error(`Failed to replace database file: ${renameErr.message}`);
        }
        
        logSync('âœ… Database sync from VM completed successfully');
        
        // 5. REOPEN DATABASE CONNECTIONS AND TRIGGER REFRESH
        logSync('ðŸ”Œ Reopening database connections...');
        const { reopenDatabaseConnection } = await import('./db');
        const reopenResult = reopenDatabaseConnection();
        logSync(`ðŸ”Œ Database reopen result: ${reopenResult}`);
        
        setTimeout(() => {
          logSync('ðŸ”„ Triggering UI refresh after database sync');
          if (webhookMainWindow) {
            webhookMainWindow.webContents.send('db-updated', {
              table: 'project_pages',
              updatedAt: new Date().toISOString()
            });
          }
        }, 1000);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ 
          success: true, 
          message: 'Database synced from VM successfully'
        }));
        
      } catch (error) {
        logSync(`ðŸ’¥ WEBHOOK DATABASE SYNC FAILED: ${error}`);
        logSync(`ðŸ’¥ Error name: ${error.name}`);
        logSync(`ðŸ’¥ Error message: ${error.message}`);
        logSync(`ðŸ’¥ Error stack: ${error.stack}`);
        
        // Clean up temp file if it exists
        if (fs.existsSync(tempDbPath)) {
          try {
            fs.unlinkSync(tempDbPath);
            console.log('ðŸ§¹ Cleaned up temp database file');
          } catch (cleanupError) {
            console.error('âŒ Failed to clean up temp file:', cleanupError);
          }
        }
        
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ 
          success: false, 
          error: error.message,
          details: error.stack
        }));
      }
    } else if (req.method === 'POST' && url.pathname === '/idea-added') {
      try {
        console.log('Received idea-added notification from n8n');
        
        // Just trigger a forced refresh of the project document
        setTimeout(() => {
          console.log('Triggering refresh after idea added');
          if (webhookMainWindow) {
            webhookMainWindow.webContents.send('db-updated', {
              table: 'project_pages',
              updatedAt: new Date().toISOString()
            });
          }
        }, 300);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true, message: 'Idea added notification received' }));
      } catch (error) {
        console.error('Idea added notification failed:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: false, error: error.message }));
      }
    } else if (req.method === 'GET' && url.pathname === '/health') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'ok', message: 'Writegeist webhook server is running' }));
    } else {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Not found' }));
    }
  });
  
  webhookServer.listen(PORT, '::', () => {
    console.log(`Writegeist webhook server running on port ${PORT}`);
    console.log(`n8n can call: http://localhost:${PORT}/sync-database`);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Start the FastAPI backend
  startApiBackend();
  
  // Start the webhook server for n8n integration
  startWebhookServer();

  // Initialize database with fresh reference capability
  let dbModule: any = null;
  
  const initializeDatabase = async () => {
    dbModule = await import('./db');
    const { db, chapters, projectPages, setDatabaseReopenCallback } = dbModule;
    const { eq } = require('drizzle-orm');
    console.log('Database initialized');
    
    // Set callback to refresh database references when reopened
    setDatabaseReopenCallback(() => {
      console.log('ðŸ”„ Refreshing database references after reopen');
      // Re-import the module to get fresh database references
      delete require.cache[require.resolve('./db')];
      initializeDatabase();
    });
    
    return { db, chapters, projectPages, eq };
  };
  
  initializeDatabase().then(({ db, chapters, projectPages, eq }) => {
    // Database connection management handlers
    ipcMain.handle('close-db-connections', async () => {
      try {
        const { closeDatabaseConnection } = dbModule;
        const result = closeDatabaseConnection();
        return { success: result };
      } catch (error) {
        console.error('Error closing database connections:', error);
        return { success: false, error: error.message };
      }
    });
    
    ipcMain.handle('reopen-db-connections', async () => {
      try {
        const { reopenDatabaseConnection } = dbModule;
        const result = reopenDatabaseConnection();
        return { success: result };
      } catch (error) {
        console.error('Error reopening database connections:', error);
        return { success: false, error: error.message };
      }
    });
    
    // Set up IPC handlers with dynamic database references
    ipcMain.handle('save-chapter', async (event, chapter) => {
      try {
        const { db, chapters } = dbModule;
        await db.insert(chapters).values({
          id: chapter.id || `chapter_${Date.now()}`,
          title: chapter.title,
          text: chapter.text,
          characters: JSON.stringify(chapter.characters || []),
          locations: JSON.stringify(chapter.locations || []),
          pov: JSON.stringify(chapter.pov || []),
        });
        return { success: true };
      } catch (error) {
        console.error('Error saving chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('get-chapters', async () => {
      try {
        const { db, chapters } = dbModule;
        const result = await db.select().from(chapters).orderBy(chapters.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting chapters:', error);
        return [];
      }
    });

    ipcMain.handle('delete-chapter', async (event, id) => {
      try {
        const { db, chapters } = dbModule;
        const { eq } = require('drizzle-orm');
        await db.delete(chapters).where(eq(chapters.id, id));
        return { success: true };
      } catch (error) {
        console.error('Error deleting chapter:', error);
        throw error;
      }
    });

    // Project document handlers
    ipcMain.handle('get-project-doc', async () => {
      try {
        const { db, projectPages } = dbModule;
        const result = await db.select().from(projectPages).limit(1);
        if (result.length > 0) {
          return result[0].markdown;
        } else {
          // Insert default markdown if none exists
          const defaultMarkdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
          await db.insert(projectPages).values({
            id: 1,
            markdown: defaultMarkdown,
          });
          return defaultMarkdown;
        }
      } catch (error) {
        console.error('Error getting project document:', error);
        throw error;
      }
    });

    ipcMain.handle('save-project-doc', async (event, markdown) => {
      try {
        const { db, projectPages } = dbModule;
        const { eq } = require('drizzle-orm');
        // Try to update first, if no rows affected, insert
        const result = await db.select().from(projectPages).where(eq(projectPages.id, 1));
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown });
        }
        return { success: true };
      } catch (error) {
        console.error('Error saving project document:', error);
        throw error;
      }
    });

    ipcMain.handle('append-characters', async (event, chars) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Characters section
        const charactersMatch = markdown.match(/^## Characters\s*$/m);
        if (!charactersMatch) {
          return { success: false, error: 'Characters section not found' };
        }
        
        // Get the position after the Characters heading
        const charactersIndex = charactersMatch.index + charactersMatch[0].length;
        
        // Extract existing characters from bullet list
        const afterCharacters = markdown.substring(charactersIndex);
        const existingCharacters = new Set<string>();
        
        // Match bullet points and extract character names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterCharacters)) !== null) {
          // Extract character name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingCharacters.add(name);
        }
        
        // Filter out characters that already exist, with better name matching
        const newCharacters = chars.filter((char: string) => {
          const charName = char.split("(")[0].trim();
          // Check if bullet already begins with "* " + name
          const existingBulletPattern = `* ${charName}`;
          return !Array.from(existingCharacters).some(existing => 
            existing.toLowerCase() === charName.toLowerCase() ||
            afterCharacters.includes(existingBulletPattern)
          );
        });
        
        if (newCharacters.length === 0) {
          return { success: true, message: 'No new characters to add' };
        }
        
        // Find the end of the Characters section (next ## heading or end of document)
        const nextSectionMatch = afterCharacters.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? charactersIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new characters using asterisk bullets
        const characterBullets = newCharacters.map((char: string) => `* ${char}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + characterBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        const { db: freshDb, projectPages: freshProjectPages } = dbModule;
        const { eq: freshEq } = require('drizzle-orm');
        await freshDb.update(freshProjectPages).set({ markdown: updatedMarkdown }).where(freshEq(freshProjectPages.id, 1));
        
        return { success: true, added: newCharacters };
      } catch (error) {
        console.error('Error appending characters:', error);
        return { success: false, error: 'Failed to append characters' };
      }
    });

    // Config management IPC handlers
    ipcMain.handle('get-config', async () => {
      try {
        return loadConfig();
      } catch (error) {
        console.error('Error getting config:', error);
        return { OPENAI_API_KEY: '', PORT: 8000 };
      }
    });

    ipcMain.handle('save-config', async (event, config) => {
      try {
        const success = saveConfig(config);
        if (success) {
          // Restart the API backend with new config
          restartApiBackend();
        }
        return { success };
      } catch (error) {
        console.error('Error saving config:', error);
        return { success: false, error: 'Failed to save config' };
      }
    });

    ipcMain.handle('update-chapter', async (event, chapter) => {
      try {
        const { db, chapters } = dbModule;
        const { eq } = require('drizzle-orm');
        
        // Helper function to ensure proper JSON string format
        const ensureJsonString = (field: any) => {
          if (typeof field === 'string') {
            try {
              // If it's already a JSON string, parse it first then re-stringify
              const parsed = JSON.parse(field);
              return JSON.stringify(parsed);
            } catch {
              // If it's not valid JSON, treat as empty array
              return JSON.stringify([]);
            }
          } else if (Array.isArray(field)) {
            return JSON.stringify(field);
          } else {
            return JSON.stringify([]);
          }
        };

        await db.update(chapters).set({
          title: chapter.title,
          text: chapter.text,
          characters: ensureJsonString(chapter.characters),
          locations: ensureJsonString(chapter.locations),
          pov: ensureJsonString(chapter.pov),
        }).where(eq(chapters.id, chapter.id));
        return { success: true };
      } catch (error) {
        console.error('Error updating chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-chapter-dynamic', async (event, payload) => {
      try {
        const { db, projectPages } = dbModule;
        const { eq } = require('drizzle-orm');
        
        // Import the smartInsert function
        const { smartInsert } = await import('./lib/markdownSync');
        
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          // Create default markdown if none exists
          markdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
        }
        
        // Apply smart insertion
        const syncedMarkdown = smartInsert(markdown, payload);
        
        // Save updated markdown
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error syncing chapter dynamically:', error);
        throw error;
      }
    });

    // VM sync IPC handler
    ipcMain.handle('sync-to-vm', async () => {
      try {
        const { exec } = await import('child_process');
        const { promisify } = await import('util');
        const execAsync = promisify(exec);
        
        // Run the PowerShell sync script
        const result = await execAsync('powershell -ExecutionPolicy Bypass -File sync-to-vm.ps1', {
          cwd: process.cwd()
        });
        
        return { success: true, output: result.stdout };
      } catch (error) {
        console.error('VM sync failed:', error);
        throw error;
      }
    });

    // VM database sync from VM to local
    ipcMain.handle('sync-from-vm', async () => {
      try {
        const { exec } = await import('child_process');
        const { promisify } = await import('util');
        const execAsync = promisify(exec);
        
        console.log('Syncing database from VM to local...');
        
        // Download updated database from VM
        await execAsync('scp root@python-fastapi-u50080.vm.elestio.app:/writegeist/writegeist.db ./writegeist_temp.db', {
          cwd: process.cwd()
        });
        
        // Replace the current database using Copy-Item which can overwrite files in use
        await execAsync('powershell -Command "Copy-Item writegeist_temp.db writegeist.db -Force; Remove-Item writegeist_temp.db -Force"', {
          cwd: process.cwd()
        });
        
        console.log('Database sync from VM completed successfully');
        return { success: true, message: 'Database synced from VM' };
      } catch (error) {
        console.error('VM database sync failed:', error);
        return { success: false, error: error.message };
      }
    });

    // Database monitoring will be started after window creation
  }).catch(console.error);
  
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Clean up the API backend process when the app is quitting
app.on('will-quit', () => {
  if (apiProcess) {
    console.log('Stopping API backend...');
    apiProcess.kill();
    apiProcess = null;
  }
  
  if (webhookServer) {
    console.log('Stopping webhook server...');
    webhookServer.close();
    webhookServer = null;
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
