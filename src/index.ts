import { app, BrowserWindow, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'node:path';
import fs from 'node:fs';
import os from 'node:os';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Track the API backend process
let apiProcess: any;

// Config management
const getConfigPath = () => {
  const configDir = path.join(os.homedir(), 'AppData', 'Roaming', 'Writegeist');
  const configFile = path.join(configDir, 'config.json');
  return { configDir, configFile };
};

const loadConfig = () => {
  const { configFile } = getConfigPath();
  try {
    if (fs.existsSync(configFile)) {
      return JSON.parse(fs.readFileSync(configFile, 'utf8'));
    }
  } catch (error) {
    console.error('Error loading config:', error);
  }
  return { OPENAI_API_KEY: '', PORT: 8000 };
};

const saveConfig = (config: any) => {
  const { configDir, configFile } = getConfigPath();
  try {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error('Error saving config:', error);
    return false;
  }
};

const restartApiBackend = () => {
  if (apiProcess) {
    console.log('Restarting API backend...');
    apiProcess.kill();
    apiProcess = null;
    
    // Wait a moment then restart
    setTimeout(() => {
      startApiBackend();
    }, 1000);
  }
};

const startApiBackend = () => {
  const config = loadConfig();
  const exePath = app.isPackaged
    ? path.join(process.resourcesPath, 'writegeist-api.exe')
    : path.join(process.cwd(), 'resources', 'writegeist-api.exe');

  // In development, use batch script that activates venv and runs uvicorn
  const usePythonSource = !app.isPackaged;
  const batchScriptPath = path.join(process.cwd(), 'ai-service', 'start_api.bat');
  const command = usePythonSource ? batchScriptPath : exePath;
  const args = usePythonSource ? [] : [];
  const cwd = usePythonSource ? undefined : undefined;

  console.log('Starting API backend from:', usePythonSource ? 'batch script (venv)' : exePath);
  
  try {
    apiProcess = spawn(command, args, { 
      stdio: 'inherit',
      cwd: cwd,
      shell: true,
      env: { 
        ...process.env, 
        WG_PORT: config.PORT || '8000',
        OPENAI_API_KEY: config.OPENAI_API_KEY || ''
      }
    });
    
    apiProcess.on('error', (error: Error) => {
      console.error('Failed to start API backend:', error);
    });
    
    apiProcess.on('exit', (code: number) => {
      console.log('API backend exited with code:', code);
    });
    
    console.log('API backend started with PID:', apiProcess.pid);
  } catch (error) {
    console.error('Error spawning API backend:', error);
  }
};

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Configure CSP to allow localhost connections
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' http://127.0.0.1:8000 http://localhost:8000; script-src 'self' 'unsafe-inline' 'unsafe-eval';"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();

  // Start database monitoring
  const dbPath = path.join(process.cwd(), 'writegeist.db');
  startDbMonitoring(dbPath, mainWindow);
};

// Database change monitoring
let dbWatcher: fs.FSWatcher | null = null;
let lastDbModified: number = 0;

const startDbMonitoring = (dbPath: string, mainWindow: BrowserWindow) => {
  try {
    // Stop existing watcher
    if (dbWatcher) {
      dbWatcher.close();
    }

    // Get initial modification time
    const stats = fs.statSync(dbPath);
    lastDbModified = stats.mtimeMs;

    // Watch for file changes
    dbWatcher = fs.watch(dbPath, (eventType) => {
      if (eventType === 'change') {
        try {
          const newStats = fs.statSync(dbPath);
          if (newStats.mtimeMs > lastDbModified) {
            lastDbModified = newStats.mtimeMs;
            
            // Notify renderer about database changes
            mainWindow.webContents.send('db-updated', {
              table: 'unknown', // We can't determine specific table from file watch
              updatedAt: new Date().toISOString()
            });
          }
        } catch (error) {
          console.warn('Error checking database modification:', error);
        }
      }
    });

    console.log('Database monitoring started');
  } catch (error) {
    console.warn('Failed to start database monitoring:', error);
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Start the FastAPI backend
  startApiBackend();

  // Initialize database
  import('./db').then(({ db, chapters, projectPages }) => {
    const { eq } = require('drizzle-orm');
    console.log('Database initialized');
    
    // Set up IPC handlers
    ipcMain.handle('save-chapter', async (event, chapter) => {
      try {
        await db.insert(chapters).values({
          id: chapter.id || `chapter_${Date.now()}`,
          title: chapter.title,
          text: chapter.text,
          characters: JSON.stringify(chapter.characters || []),
          locations: JSON.stringify(chapter.locations || []),
          pov: JSON.stringify(chapter.pov || []),
        });
        return { success: true };
      } catch (error) {
        console.error('Error saving chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('get-chapters', async () => {
      try {
        const result = await db.select().from(chapters).orderBy(chapters.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting chapters:', error);
        return [];
      }
    });

    ipcMain.handle('delete-chapter', async (event, id) => {
      try {
        await db.delete(chapters).where(eq(chapters.id, id));
        return { success: true };
      } catch (error) {
        console.error('Error deleting chapter:', error);
        throw error;
      }
    });

    // Project document handlers
    ipcMain.handle('get-project-doc', async () => {
      try {
        const result = await db.select().from(projectPages).limit(1);
        if (result.length > 0) {
          return result[0].markdown;
        } else {
          // Insert default markdown if none exists
          const defaultMarkdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
          await db.insert(projectPages).values({
            id: 1,
            markdown: defaultMarkdown,
          });
          return defaultMarkdown;
        }
      } catch (error) {
        console.error('Error getting project document:', error);
        throw error;
      }
    });

    ipcMain.handle('save-project-doc', async (event, markdown) => {
      try {
        // Try to update first, if no rows affected, insert
        const result = await db.select().from(projectPages).where(eq(projectPages.id, 1));
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown });
        }
        return { success: true };
      } catch (error) {
        console.error('Error saving project document:', error);
        throw error;
      }
    });

    ipcMain.handle('append-characters', async (event, chars) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Characters section
        const charactersMatch = markdown.match(/^## Characters\s*$/m);
        if (!charactersMatch) {
          return { success: false, error: 'Characters section not found' };
        }
        
        // Get the position after the Characters heading
        const charactersIndex = charactersMatch.index + charactersMatch[0].length;
        
        // Extract existing characters from bullet list
        const afterCharacters = markdown.substring(charactersIndex);
        const existingCharacters = new Set<string>();
        
        // Match bullet points and extract character names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterCharacters)) !== null) {
          // Extract character name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingCharacters.add(name);
        }
        
        // Filter out characters that already exist, with better name matching
        const newCharacters = chars.filter((char: string) => {
          const charName = char.split("(")[0].trim();
          // Check if bullet already begins with "* " + name
          const existingBulletPattern = `* ${charName}`;
          return !Array.from(existingCharacters).some(existing => 
            existing.toLowerCase() === charName.toLowerCase() ||
            afterCharacters.includes(existingBulletPattern)
          );
        });
        
        if (newCharacters.length === 0) {
          return { success: true, message: 'No new characters to add' };
        }
        
        // Find the end of the Characters section (next ## heading or end of document)
        const nextSectionMatch = afterCharacters.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? charactersIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new characters using asterisk bullets
        const characterBullets = newCharacters.map((char: string) => `* ${char}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + characterBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newCharacters };
      } catch (error) {
        console.error('Error appending characters:', error);
        return { success: false, error: 'Failed to append characters' };
      }
    });

    // Config management IPC handlers
    ipcMain.handle('get-config', async () => {
      try {
        return loadConfig();
      } catch (error) {
        console.error('Error getting config:', error);
        return { OPENAI_API_KEY: '', PORT: 8000 };
      }
    });

    ipcMain.handle('save-config', async (event, config) => {
      try {
        const success = saveConfig(config);
        if (success) {
          // Restart the API backend with new config
          restartApiBackend();
        }
        return { success };
      } catch (error) {
        console.error('Error saving config:', error);
        return { success: false, error: 'Failed to save config' };
      }
    });

    ipcMain.handle('update-chapter', async (event, chapter) => {
      try {
        // Helper function to ensure proper JSON string format
        const ensureJsonString = (field: any) => {
          if (typeof field === 'string') {
            try {
              // If it's already a JSON string, parse it first then re-stringify
              const parsed = JSON.parse(field);
              return JSON.stringify(parsed);
            } catch {
              // If it's not valid JSON, treat as empty array
              return JSON.stringify([]);
            }
          } else if (Array.isArray(field)) {
            return JSON.stringify(field);
          } else {
            return JSON.stringify([]);
          }
        };

        await db.update(chapters).set({
          title: chapter.title,
          text: chapter.text,
          characters: ensureJsonString(chapter.characters),
          locations: ensureJsonString(chapter.locations),
          pov: ensureJsonString(chapter.pov),
        }).where(eq(chapters.id, chapter.id));
        return { success: true };
      } catch (error) {
        console.error('Error updating chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-chapter-dynamic', async (event, payload) => {
      try {
        // Import the smartInsert function
        const { smartInsert } = await import('./lib/markdownSync');
        
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          // Create default markdown if none exists
          markdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
        }
        
        // Apply smart insertion
        const syncedMarkdown = smartInsert(markdown, payload);
        
        // Save updated markdown
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error syncing chapter dynamically:', error);
        throw error;
      }
    });

    // Start database monitoring after initialization
    const dbPath = path.join(process.cwd(), 'writegeist.db');
    // We'll start monitoring once the window is created
  }).catch(console.error);
  
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Clean up the API backend process when the app is quitting
app.on('will-quit', () => {
  if (apiProcess) {
    console.log('Stopping API backend...');
    apiProcess.kill();
    apiProcess = null;
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
