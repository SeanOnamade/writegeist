import { app, BrowserWindow, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'node:path';
import fs from 'node:fs';
import os from 'node:os';
const http = require('node:http');
import { URL } from 'node:url';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}



// Track the API backend process
let apiProcess: any;

// Track the webhook server
let webhookServer: any;

// Config management
const getConfigPath = () => {
  const configDir = path.join(os.homedir(), 'AppData', 'Roaming', 'Writegeist');
  const configFile = path.join(configDir, 'config.json');
  return { configDir, configFile };
};

const loadConfig = () => {
  const { configFile } = getConfigPath();
  try {
    if (fs.existsSync(configFile)) {
      return JSON.parse(fs.readFileSync(configFile, 'utf8'));
    }
  } catch (error) {
    console.error('Error loading config:', error);
  }
  return { OPENAI_API_KEY: '', PORT: 8000 };
};

const saveConfig = (config: any) => {
  const { configDir, configFile } = getConfigPath();
  try {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error('Error saving config:', error);
    return false;
  }
};

const restartApiBackend = () => {
  if (apiProcess) {
    console.log('Restarting API backend...');
    apiProcess.kill();
    apiProcess = null;
    
    // Wait a moment then restart
    setTimeout(() => {
      startApiBackend();
    }, 1000);
  }
};

const startApiBackend = () => {
  const config = loadConfig();
  const exePath = app.isPackaged
    ? path.join(process.resourcesPath, 'writegeist-api.exe')
    : path.join(process.cwd(), 'resources', 'writegeist-api.exe');

  // In development, use batch script that activates venv and runs uvicorn
  const usePythonSource = !app.isPackaged;
  const batchScriptPath = path.join(process.cwd(), 'ai-service', 'start_api.bat');
  const command = usePythonSource ? batchScriptPath : exePath;
  const args = usePythonSource ? [] : [];
  const cwd = usePythonSource ? undefined : undefined;

  console.log('Starting API backend from:', usePythonSource ? 'batch script (venv)' : exePath);
  
  try {
    apiProcess = spawn(command, args, { 
      stdio: 'inherit',
      cwd: cwd,
      shell: true,
      env: { 
        ...process.env, 
        WG_PORT: config.PORT || '8000',
        OPENAI_API_KEY: config.OPENAI_API_KEY || ''
      }
    });
    
    apiProcess.on('error', (error: Error) => {
      console.error('Failed to start API backend:', error);
    });
    
    apiProcess.on('exit', (code: number) => {
      console.log('API backend exited with code:', code);
    });
    
    console.log('API backend started with PID:', apiProcess.pid);
  } catch (error) {
    console.error('Error spawning API backend:', error);
  }
};

let globalMainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    icon: path.join(process.cwd(), 'resources', 'logo.ico'),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      // webSecurity: true (default) - Secure by default
    },
  });

  // Store global reference for webhook server
  globalMainWindow = mainWindow;

  // Configure CSP to allow localhost connections
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
                    process.env.NODE_ENV === 'development' || !app.isPackaged
                      ? "default-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' http://127.0.0.1:8000 http://127.0.0.1:9876 http://localhost:8000 ws://localhost:3000 ws://0.0.0.0:3000 https://n8n-writegeist-u50080.vm.elestio.app https://python-fastapi-u50080.vm.elestio.app; script-src 'self' 'unsafe-inline' 'unsafe-eval'; media-src 'self' http://127.0.0.1:9876;"
                      : "default-src 'self'; connect-src 'self' http://127.0.0.1:8000 http://127.0.0.1:9876 https://n8n-writegeist-u50080.vm.elestio.app https://python-fastapi-u50080.vm.elestio.app; script-src 'self'; media-src 'self' http://127.0.0.1:9876;"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only in development
  if (process.env.NODE_ENV === 'development' || !app.isPackaged) {
    mainWindow.webContents.openDevTools();
  }

  // Start database monitoring
  const dbPath = path.join(process.cwd(), 'writegeist.db');
  startDbMonitoring(dbPath, mainWindow);
};

// Database change monitoring
let dbWatcher: fs.FSWatcher | null = null;
let lastDbModified: number = 0;

// Database sync safety system
// Centralized sync operation queue to prevent concurrent operations
class SyncOperationQueue {
  private queue: Array<() => Promise<any>> = [];
  private isProcessing = false;

  async add<T>(operation: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await operation();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processQueue();
    });
  }

  private async processQueue() {
    if (this.isProcessing || this.queue.length === 0) {
      return;
    }

    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const operation = this.queue.shift();
      if (operation) {
        try {
          await operation();
        } catch (error) {
          console.error('Sync operation failed:', error);
        }
      }
    }
    
    this.isProcessing = false;
  }
}

const syncQueue = new SyncOperationQueue();
let syncMutex = false;
let dbConnection: any = null;

const createSafeBackup = (reason: string = 'sync') => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupPath = `writegeist_backup_${reason}_${timestamp}.db`;
    const fs = require('fs');
    
    if (fs.existsSync('writegeist.db')) {
      const stats = fs.statSync('writegeist.db');
      if (stats.size > 0) {
        fs.copyFileSync('writegeist.db', backupPath);
        console.log(`Safe backup created: ${backupPath} (${reason})`);
        
        // Clean up old backups after creating new one
        cleanupOldBackups();
        
        return backupPath;
      }
    }
    return null;
  } catch (error) {
    console.error(`Failed to create safe backup: ${error.message}`);
    return null;
  }
};

const cleanupOldBackups = () => {
  try {
    const fs = require('fs');
    
    // Get all backup files (including all types)
    const allBackupFiles = fs.readdirSync('.')
      .filter(file => 
        (file.startsWith('writegeist_backup_') || 
         file.startsWith('writegeist_temp_') || 
         file.startsWith('writegeist_corrupted_') ||
         file.startsWith('writegeist_from_vm') ||
         file.startsWith('writegeist_latest')) && 
        file.endsWith('.db')
      )
      .map(file => {
        const stats = fs.statSync(file);
        return {
          name: file,
          mtime: stats.mtime,
          size: stats.size
        };
      })
      .sort((a, b) => b.mtime.getTime() - a.mtime.getTime()); // Sort by modification time, newest first
    
    // Keep only the last 15 backups (increased from 10 for safety)
    if (allBackupFiles.length > 15) {
      const filesToDelete = allBackupFiles.slice(15);
      let deletedCount = 0;
      
      filesToDelete.forEach(fileInfo => {
        try {
          // Don't delete very recent files (less than 1 hour old) as safety measure
          const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
          if (fileInfo.mtime < hourAgo) {
            fs.unlinkSync(fileInfo.name);
            deletedCount++;
            console.log(`Deleted old backup: ${fileInfo.name}`);
          }
        } catch (error) {
          console.warn(`Could not delete old backup ${fileInfo.name}:`, error.message);
        }
      });
      
      if (deletedCount > 0) {
        console.log(`Cleaned up ${deletedCount} old backup files`);
      }
    }
  } catch (error) {
    console.warn('Could not cleanup old backups:', error.message);
  }
};

const checkDatabaseIntegrity = async (dbPath: string): Promise<boolean> => {
  try {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    // Try using sqlite3 command first
    try {
      const result = await execAsync(`sqlite3 "${dbPath}" "PRAGMA integrity_check;"`, {
        timeout: 5000
      });
      
      return result.stdout.trim() === 'ok';
    } catch (sqliteError) {
      console.warn('sqlite3 command not available, using fallback integrity check');
      
      // Fallback: Basic file checks
      const fs = require('fs');
      if (!fs.existsSync(dbPath)) {
        return false;
      }
      
      const stats = fs.statSync(dbPath);
      if (stats.size === 0) {
        return false;
      }
      
      // Try to open with better-sqlite3 (which is already a dependency)
      try {
        const Database = require('better-sqlite3');
        const db = new Database(dbPath, { readonly: true });
        
        // Try a simple query to verify database structure
        const result = db.prepare("SELECT name FROM sqlite_master WHERE type='table' LIMIT 1").get();
        db.close();
        
        return result !== undefined;
      } catch (dbError) {
        console.error('Database integrity check failed:', dbError.message);
        return false;
      }
    }
  } catch (error) {
    console.error(`Database integrity check failed: ${error.message}`);
    return false;
  }
};

const safeDatabaseSync = async (operation: 'from-vm' | 'to-vm' | 'webhook', options: any = {}) => {
  // Prevent concurrent sync operations
  if (syncMutex) {
    console.warn('Sync operation already in progress, skipping...');
    return { success: false, error: 'Sync already in progress' };
  }
  
  syncMutex = true;
  
  try {
    console.log(`Starting safe database sync: ${operation}`);
    
    // Step 1: Create backup before any sync operation
    const backupPath = createSafeBackup(operation);
    if (!backupPath) {
      throw new Error('Failed to create safety backup');
    }
    
    // Step 2: Wait for any pending database operations to complete
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Step 3: Perform the sync operation
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    let syncResult;
    
    if (operation === 'from-vm') {
      // Download database from VM
      console.log('Downloading database from VM...');
      await execAsync('scp root@python-fastapi-u50080.vm.elestio.app:/writegeist/writegeist.db ./writegeist_temp_safe.db', {
        cwd: process.cwd(),
        timeout: 30000
      });
      
      // Check integrity of downloaded database
      const isIntact = await checkDatabaseIntegrity('./writegeist_temp_safe.db');
      if (!isIntact) {
        throw new Error('Downloaded database failed integrity check');
      }
      
      // Safely replace database (app will restart)
      console.log('Database integrity verified. Replacing database and restarting...');
      await execAsync('powershell -Command "Move-Item writegeist_temp_safe.db writegeist.db -Force"', {
        cwd: process.cwd()
      });
      
      // Restart application to reinitialize database connections
      console.log('Restarting application for safe database reload...');
      app.relaunch();
      app.exit(0);
      
    } else if (operation === 'to-vm') {
      // Upload database to VM (non-interactive)
      console.log('Uploading database to VM...');
      
      // Use the existing sync script but with timeout and proper error handling
      syncResult = await execAsync('powershell -ExecutionPolicy Bypass -File sync-to-vm.ps1', {
        cwd: process.cwd(),
        timeout: 120000 // 2 minutes timeout
      });
      
    } else if (operation === 'webhook') {
      // Webhook-triggered sync
      console.log('Webhook sync - downloading from VM...');
      await execAsync('scp root@python-fastapi-u50080.vm.elestio.app:/writegeist/writegeist.db ./writegeist_temp_safe.db', {
        cwd: process.cwd(),
        timeout: 30000
      });
      
      const isIntact = await checkDatabaseIntegrity('./writegeist_temp_safe.db');
      if (!isIntact) {
        throw new Error('Webhook database failed integrity check');
      }
      
      await execAsync('powershell -Command "Move-Item writegeist_temp_safe.db writegeist.db -Force"', {
        cwd: process.cwd()
      });
      
      // For webhook, we restart the app
      console.log('Webhook sync complete. Restarting application...');
      setTimeout(() => {
        app.relaunch();
        app.exit(0);
      }, 1000);
    }
    
    console.log(`Safe database sync completed: ${operation}`);
    
    // Cleanup temp files after successful sync
    try {
      const fs = require('fs');
      if (fs.existsSync('writegeist_temp_safe.db')) {
        fs.unlinkSync('writegeist_temp_safe.db');
      }
      // Clean up any other temp files
      cleanupOldBackups();
    } catch (cleanupError) {
      console.warn('Failed to cleanup temp files after successful sync:', cleanupError.message);
    }
    
    return { success: true, message: `Safe ${operation} sync completed`, output: syncResult?.stdout };
    
  } catch (error) {
    console.error(`Safe database sync failed (${operation}):`, error);
    
    // Cleanup temp files on error
    try {
      const fs = require('fs');
      if (fs.existsSync('writegeist_temp_safe.db')) {
        fs.unlinkSync('writegeist_temp_safe.db');
      }
    } catch (cleanupError) {
      console.warn('Failed to cleanup temp files:', cleanupError.message);
    }
    
    return { success: false, error: error.message };
  } finally {
    syncMutex = false;
  }
};

const startDbMonitoring = (dbPath: string, mainWindow: BrowserWindow) => {
  try {
    // Stop existing watcher
    if (dbWatcher) {
      dbWatcher.close();
    }

    // Get initial modification time
    const stats = fs.statSync(dbPath);
    lastDbModified = stats.mtimeMs;

    // Watch for file changes
    // DISABLED: File watcher functionality to prevent infinite loops
    // dbWatcher = fs.watch(dbPath, (eventType) => {
    //   if (eventType === 'change') {
    //     try {
    //       const newStats = fs.statSync(dbPath);
    //       if (newStats.mtimeMs > lastDbModified) {
    //         lastDbModified = newStats.mtimeMs;
    //         
    //         // Notify renderer about database changes
    //         mainWindow.webContents.send('db-updated', {
    //           table: 'unknown', // We can't determine specific table from file watch
    //           updatedAt: new Date().toISOString()
    //         });
    //       }
    //     } catch (error) {
    //       console.warn('Error checking database modification:', error);
    //     }
    //   }
    // });

    console.log('Database monitoring started');
        } catch (error) {
    console.warn('Failed to start database monitoring:', error);
        }
};

// Helper function to insert content into a specific markdown section
function insertContentIntoSection(markdown: string, sectionName: string, content: string): string {
  // Ensure the section exists
  const sectionHeader = `## ${sectionName}`;
  if (!markdown.includes(sectionHeader)) {
    markdown += `\n\n${sectionHeader}\n`;
  }
  
  // Find the section content
  const sectionRegex = new RegExp(`(## ${escapeRegExp(sectionName)}[\\s\\S]*?)(?=\\n## |$)`, "m");
  const match = markdown.match(sectionRegex);
  
  if (match) {
    let section = match[0];
    
    // Add content as bullet points if it doesn't already exist
    const contentLines = content.split('\n').filter(line => line.trim());
    contentLines.forEach(line => {
      const bulletPoint = `* ${line.trim()}`;
      if (!section.includes(line.trim())) {
        if (!section.endsWith('\n')) {
          section += '\n';
        }
        section += `${bulletPoint}\n`;
      }
    });
    
    // Replace the section in the markdown
    return markdown.replace(sectionRegex, section);
  } else {
    // If section not found, append it
    return markdown + `\n\n${sectionHeader}\n* ${content}\n`;
  }
}

// Helper function to escape regex special characters
function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

// Webhook server for n8n to trigger database syncing
const startWebhookServer = (mainWindow: BrowserWindow) => {
  const PORT = 3001; // Use a different port from the main API
  
  webhookServer = http.createServer(async (req, res) => {
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }
    
    const url = new URL(req.url!, `http://localhost:${PORT}`);
    
    if (req.method === 'POST' && url.pathname === '/sync-database') {
      try {
        console.log('Received database sync webhook from n8n');
        
        // Use safe sync system
        const result = await safeDatabaseSync('webhook');
        
        if (result.success) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ success: true, message: 'Database synced safely via webhook' }));
        } else {
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ success: false, error: result.error }));
        }
      } catch (error) {
        console.error('Webhook database sync failed:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: false, error: error.message }));
      }
    } else if (req.method === 'POST' && url.pathname === '/sync-chapter-dynamic') {
      try {
        console.log('Received sync-chapter-dynamic webhook from n8n');
        
        // Parse request body
        let body = '';
        req.on('data', chunk => {
          body += chunk.toString();
        });
        
        req.on('end', async () => {
          try {
            const payload = JSON.parse(body);
            
            // Import the smartInsert function and database
            const { smartInsert } = await import('./lib/markdownSync');
            const { db, projectPages } = await import('./db');
            const { eq } = await import('drizzle-orm');
            
            // Get current markdown
            const result = await db.select().from(projectPages).limit(1);
            let markdown: string;
            
            if (result.length > 0) {
              markdown = result[0].markdown;
            } else {
              // Create default markdown if none exists
              markdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
            }
            
            // Check if payload is in section/content format or full SyncPayload format
            let syncedMarkdown: string;
            if (payload.section && payload.content) {
              // Handle section/content format - insert content directly into specified section
              syncedMarkdown = insertContentIntoSection(markdown, payload.section, payload.content);
            } else {
              // Handle full SyncPayload format
              syncedMarkdown = smartInsert(markdown, payload);
            }
            
            // Save updated markdown
            if (result.length > 0) {
              await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
            } else {
              await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
            }
            
            console.log('Chapter dynamic sync completed successfully');
            console.log('Payload received:', JSON.stringify(payload, null, 2));
            
            // Notify renderer about the update
            if (mainWindow && !mainWindow.isDestroyed()) {
              mainWindow.webContents.send('project-doc-updated');
            }
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ success: true, message: 'Chapter synced successfully' }));
          } catch (parseError) {
            console.error('Error parsing sync-chapter-dynamic payload:', parseError);
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ success: false, error: 'Invalid JSON payload' }));
          }
        });
      } catch (error) {
        console.error('Sync-chapter-dynamic webhook failed:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: false, error: error.message }));
      }
    } else {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: false, error: 'Not found' }));
    }
  });
  
  webhookServer.listen(PORT, () => {
    console.log(`Webhook server listening on port ${PORT}`);
  });
};

// System health check for safety systems
const performSystemHealthCheck = async () => {
  console.log('🔍 Performing system health check...');
  
  const healthStatus = {
    backupSystem: false,
    integrityCheck: false,
    syncSafety: false,
    databaseConnection: false
  };
  
  try {
    // Test backup system
    const backupPath = createSafeBackup('health-check');
    if (backupPath) {
      healthStatus.backupSystem = true;
      console.log('✅ Backup system working');
      
      // Clean up test backup
      try {
        const fs = require('fs');
        fs.unlinkSync(backupPath);
      } catch (cleanupError) {
        console.warn('Could not cleanup test backup:', cleanupError.message);
      }
    } else {
      console.warn('❌ Backup system failed');
    }
    
    // Test integrity check
    const integrityOk = await checkDatabaseIntegrity('writegeist.db');
    if (integrityOk) {
      healthStatus.integrityCheck = true;
      console.log('✅ Database integrity check working');
    } else {
      console.warn('❌ Database integrity check failed');
    }
    
    // Test database connection
    if (dbConnection) {
      try {
        // Try a simple query - check if we can access the database
        const fs = require('fs');
        if (fs.existsSync('writegeist.db')) {
          const stats = fs.statSync('writegeist.db');
          if (stats.size > 0) {
            healthStatus.databaseConnection = true;
            console.log('✅ Database connection working');
          }
        }
      } catch (dbError) {
        console.warn('❌ Database connection test failed:', dbError.message);
      }
    }
    
    // Test sync safety (mutex)
    if (!syncMutex) {
      healthStatus.syncSafety = true;
      console.log('✅ Sync safety system ready');
    } else {
      console.warn('❌ Sync mutex already active');
    }
    
    const allSystemsGo = Object.values(healthStatus).every(status => status);
    
    if (allSystemsGo) {
      console.log('🎉 All safety systems operational!');
    } else {
      console.warn('⚠️ Some safety systems need attention:', healthStatus);
    }
    
    return healthStatus;
    
  } catch (error) {
    console.error('System health check failed:', error);
    return healthStatus;
  }
};

// Start a secure HTTP server to serve audio files
let audioServer: any = null;
const startAudioServer = () => {
  const audioDir = path.join(os.homedir(), 'AppData', 'Roaming', 'Writegeist', 'audio');
  const port = 9876; // Fixed port for audio server
  
  audioServer = http.createServer((req: any, res: any) => {
    // Enable CORS for localhost only
    res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
    res.setHeader('Access-Control-Allow-Methods', 'GET');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }
    
    if (req.method !== 'GET') {
      res.writeHead(405);
      res.end('Method Not Allowed');
      return;
    }
    
    // Parse the URL and extract filename
    const url = new URL(req.url, `http://localhost:${port}`);
    const filename = path.basename(url.pathname);
    
    // Security: Only allow specific audio file extensions
    if (!/\.(mp3|wav|ogg|m4a)$/i.test(filename)) {
      res.writeHead(400);
      res.end('Invalid file type');
      return;
    }
    
    // Security: Prevent path traversal
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      res.writeHead(400);
      res.end('Invalid filename');
      return;
    }
    
    const filePath = path.join(audioDir, filename);
    
    // Security: Ensure file is within audio directory
    if (!filePath.startsWith(audioDir)) {
      res.writeHead(403);
      res.end('Access denied');
      return;
    }
    
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      res.writeHead(404);
      res.end('File not found');
      return;
    }
    
    // Serve the audio file with proper headers
    res.setHeader('Content-Type', 'audio/mpeg');
    res.setHeader('Accept-Ranges', 'bytes');
    
    // Handle range requests for seeking
    const stat = fs.statSync(filePath);
    const range = req.headers.range;
    
    if (range) {
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : stat.size - 1;
      const chunksize = (end - start) + 1;
      
      res.writeHead(206, {
        'Content-Range': `bytes ${start}-${end}/${stat.size}`,
        'Content-Length': chunksize,
      });
      
      const stream = fs.createReadStream(filePath, { start, end });
      stream.pipe(res);
    } else {
      res.writeHead(200, {
        'Content-Length': stat.size,
      });
      fs.createReadStream(filePath).pipe(res);
    }
  });
  
  audioServer.listen(port, '127.0.0.1', () => {
    console.log(`Secure audio server running at http://127.0.0.1:${port}`);
  });
  
  audioServer.on('error', (err: any) => {
    console.error('Audio server error:', err);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Start secure audio server
  startAudioServer();
  
  // Check if AI service is already running (e.g., from start-with-ai.js)
  // If SKIP_AI_SERVICE env var is set, don't start our own AI service
  if (!process.env.SKIP_AI_SERVICE) {
    // Start the FastAPI backend
    startApiBackend();
  } else {
    console.log('Skipping AI service startup - already managed externally');
  }
  
  // Start the webhook server for n8n integration - will be started after window creation
  let webhookServerStarted = false;

  // Initialize database with backup system
  import('./db').then(({ db, chapters, projectPages }) => {
    const { eq } = require('drizzle-orm');
    console.log('Database initialized');
    
    // Store database connection for safe sync operations
    dbConnection = db;
    
    // Create automatic backup system
    const createBackup = () => {
      try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const backupPath = `writegeist_backup_${timestamp}.db`;
        const fs = require('fs');
        
        // Only create backup if main database exists and has content
        if (fs.existsSync('writegeist.db')) {
          const stats = fs.statSync('writegeist.db');
          if (stats.size > 0) {
            fs.copyFileSync('writegeist.db', backupPath);
            console.log(`Database backup created: ${backupPath}`);
            
            // Clean up old backups using unified cleanup system
            cleanupOldBackups();
          }
        }
      } catch (error) {
        console.warn('Could not create database backup:', error.message);
      }
    };
    
    // Create initial backup
    createBackup();
    
    // Set up periodic backups every 30 minutes
    setInterval(createBackup, 30 * 60 * 1000);
    
    // Perform system health check after database initialization
    setTimeout(() => {
      performSystemHealthCheck();
    }, 2000);
    
    // Set up IPC handlers
    ipcMain.handle('save-chapter', async (event, chapter) => {
      try {
        // Get the current highest order to set the new chapter at the end
        const { desc } = await import('drizzle-orm');
        const maxOrderResult = await db.select().from(chapters).orderBy(desc(chapters.order)).limit(1);
        const nextOrder = maxOrderResult.length > 0 ? (maxOrderResult[0].order || 0) + 1 : 0;
        
        const chapterId = chapter.id || `chapter_${Date.now()}`;
        
        await db.insert(chapters).values({
          id: chapterId,
          title: chapter.title,
          text: chapter.text,
          characters: JSON.stringify(chapter.characters || []),
          locations: JSON.stringify(chapter.locations || []),
          pov: JSON.stringify(chapter.pov || []),
          order: nextOrder,
        });
        
        // Automatically generate embeddings for the new chapter
        try {
          const response = await fetch(`http://localhost:8000/embeddings/generate/${chapterId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings generated for new chapter:', chapterId);
          } else {
            console.warn('Failed to generate embeddings for new chapter:', chapterId);
          }
        } catch (error) {
          console.warn('Could not generate embeddings (AI service may not be running):', error);
        }
        
        // Create backup after successful chapter save
        try {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const backupPath = `writegeist_backup_${timestamp}.db`;
          const fs = require('fs');
          fs.copyFileSync('writegeist.db', backupPath);
          console.log(`Chapter save backup created: ${backupPath}`);
        } catch (backupError) {
          console.warn('Could not create chapter save backup:', backupError.message);
        }
        
        // Trigger audio generation in background (non-blocking)
        try {
          // Check if audio already exists for this chapter
          const { chapterAudio } = require('./db');
          const existingAudio = await db.select().from(chapterAudio)
            .where(eq(chapterAudio.chapterId, chapterId))
            .limit(1);
          
          // Only generate if no audio exists or if the last attempt failed
          if (existingAudio.length === 0 || existingAudio[0].status === 'error') {
            fetch('http://localhost:8000/audio/generate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ chapter_id: chapterId }),
            }).catch(error => {
              console.log('Audio generation request failed (non-critical):', error.message);
            });
          }
        } catch (audioError) {
          console.log('Could not trigger audio generation (non-critical):', audioError.message);
        }
        
        return { success: true, chapterId };
      } catch (error) {
        console.error('Error saving chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('get-chapters', async () => {
      try {
        const result = await db.select().from(chapters).orderBy(chapters.order, chapters.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting chapters:', error);
        return [];
      }
    });

    ipcMain.handle('delete-chapter', async (event, id) => {
      try {
        await db.delete(chapters).where(eq(chapters.id, id));
        
        // Clean up embeddings for the deleted chapter
        try {
          const response = await fetch(`http://localhost:8000/embeddings/cleanup/${id}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings cleaned up for deleted chapter:', id);
          } else {
            console.warn('Failed to clean up embeddings for deleted chapter:', id);
          }
        } catch (error) {
          console.warn('Could not clean up embeddings (AI service may not be running):', error);
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error deleting chapter:', error);
        throw error;
      }
    });

    // Project document handlers
    ipcMain.handle('get-project-doc', async () => {
      try {
        const result = await db.select().from(projectPages).limit(1);
        if (result.length > 0) {
          return result[0].markdown;
        } else {
          // Insert default markdown if none exists
          const defaultMarkdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
          await db.insert(projectPages).values({
            id: 1,
            markdown: defaultMarkdown,
          });
          return defaultMarkdown;
        }
      } catch (error) {
        console.error('Error getting project document:', error);
        throw error;
      }
    });

    ipcMain.handle('save-project-doc', async (event, markdown) => {
      try {
        // Try to update first, if no rows affected, insert
        const result = await db.select().from(projectPages).where(eq(projectPages.id, 1));
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown });
        }
        return { success: true };
      } catch (error) {
        console.error('Error saving project document:', error);
        throw error;
      }
    });

    ipcMain.handle('append-characters', async (event, chars) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Characters section
        const charactersMatch = markdown.match(/^## Characters\s*$/m);
        if (!charactersMatch) {
          return { success: false, error: 'Characters section not found' };
        }
        
        // Get the position after the Characters heading
        const charactersIndex = charactersMatch.index + charactersMatch[0].length;
        
        // Extract existing characters from bullet list
        const afterCharacters = markdown.substring(charactersIndex);
        const existingCharacters = new Set<string>();
        
        // Match bullet points and extract character names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterCharacters)) !== null) {
          // Extract character name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingCharacters.add(name);
        }
        
        // Filter out characters that already exist, with better name matching
        const newCharacters = chars.filter((char: string) => {
          const charName = char.split("(")[0].trim();
          // Check if bullet already begins with "* " + name
          const existingBulletPattern = `* ${charName}`;
          return !Array.from(existingCharacters).some(existing => 
            existing.toLowerCase() === charName.toLowerCase() ||
            afterCharacters.includes(existingBulletPattern)
          );
        });
        
        if (newCharacters.length === 0) {
          return { success: true, message: 'No new characters to add' };
        }
        
        // Find the end of the Characters section (next ## heading or end of document)
        const nextSectionMatch = afterCharacters.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? charactersIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new characters using asterisk bullets
        const characterBullets = newCharacters.map((char: string) => `* ${char}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + characterBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newCharacters };
      } catch (error) {
        console.error('Error appending characters:', error);
        return { success: false, error: 'Failed to append characters' };
      }
    });

    ipcMain.handle('append-locations', async (event, locations) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Setting section
        const settingMatch = markdown.match(/^## Setting\s*$/m);
        if (!settingMatch) {
          return { success: false, error: 'Setting section not found' };
        }
        
        // Get the position after the Setting heading
        const settingIndex = settingMatch.index + settingMatch[0].length;
        
        // Extract existing locations from bullet list
        const afterSetting = markdown.substring(settingIndex);
        const existingLocations = new Set<string>();
        
        // Match bullet points and extract location names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterSetting)) !== null) {
          // Extract location name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingLocations.add(name);
        }
        
        // Filter out locations that already exist
        const newLocations = locations.filter((location: string) => {
          const locationName = location.split("(")[0].trim();
          const existingBulletPattern = `* ${locationName}`;
          return !Array.from(existingLocations).some(existing => 
            existing.toLowerCase() === locationName.toLowerCase() ||
            afterSetting.includes(existingBulletPattern)
          );
        });
        
        if (newLocations.length === 0) {
          return { success: true, message: 'No new locations to add' };
        }
        
        // Find the end of the Setting section (next ## heading or end of document)
        const nextSectionMatch = afterSetting.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? settingIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new locations using asterisk bullets
        const locationBullets = newLocations.map((location: string) => `* ${location}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + locationBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newLocations };
      } catch (error) {
        console.error('Error appending locations:', error);
        return { success: false, error: 'Failed to append locations' };
      }
    });

    ipcMain.handle('append-summaries', async (event, summaries) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Full Outline section
        const outlineMatch = markdown.match(/^## Full Outline\s*$/m);
        if (!outlineMatch) {
          return { success: false, error: 'Full Outline section not found' };
        }
        
        // Get the position after the Full Outline heading
        const outlineIndex = outlineMatch.index + outlineMatch[0].length;
        
        // Extract existing summaries from bullet list
        const afterOutline = markdown.substring(outlineIndex);
        const existingSummaries = new Set<string>();
        
        // Match bullet points and extract summary text
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterOutline)) !== null) {
          // Extract summary text (first 50 characters for comparison)
          const summaryText = match[1].substring(0, 50).trim().toLowerCase();
          existingSummaries.add(summaryText);
        }
        
        // Filter out summaries that already exist (check first 50 characters)
        const newSummaries = summaries.filter((summary: string) => {
          const summaryText = summary.substring(0, 50).trim().toLowerCase();
          return !existingSummaries.has(summaryText);
        });
        
        if (newSummaries.length === 0) {
          return { success: true, message: 'No new summaries to add' };
        }
        
        // Find the end of the Full Outline section (next ## heading or end of document)
        const nextSectionMatch = afterOutline.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? outlineIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new summaries using asterisk bullets
        const summaryBullets = newSummaries.map((summary: string) => `* ${summary}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + summaryBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newSummaries };
      } catch (error) {
        console.error('Error appending summaries:', error);
        return { success: false, error: 'Failed to append summaries' };
      }
    });

    // Config management IPC handlers
    ipcMain.handle('get-config', async () => {
      try {
        return loadConfig();
      } catch (error) {
        console.error('Error getting config:', error);
        return { OPENAI_API_KEY: '', PORT: 8000 };
      }
    });

    ipcMain.handle('save-config', async (event, config) => {
      try {
        const success = saveConfig(config);
        if (success) {
          // Restart the API backend with new config
          restartApiBackend();
        }
        return { success };
      } catch (error) {
        console.error('Error saving config:', error);
        return { success: false, error: 'Failed to save config' };
      }
    });

    ipcMain.handle('update-chapter', async (event, chapter) => {
      try {
        console.log('Updating chapter:', chapter.id, 'Title:', chapter.title, 'Text length:', chapter.text?.length);
        
        // Helper function to ensure proper JSON string format
        const ensureJsonString = (field: any) => {
          if (typeof field === 'string') {
            try {
              // If it's already a JSON string, parse it first then re-stringify
              const parsed = JSON.parse(field);
              return JSON.stringify(parsed);
            } catch {
              // If it's not valid JSON, treat as empty array
              return JSON.stringify([]);
            }
          } else if (Array.isArray(field)) {
            return JSON.stringify(field);
          } else {
            return JSON.stringify([]);
          }
        };

        const updateData = {
          title: chapter.title,
          text: chapter.text,
          characters: ensureJsonString(chapter.characters),
          locations: ensureJsonString(chapter.locations),
          pov: ensureJsonString(chapter.pov),
        };
        
        console.log('Update data:', updateData);
        
        const result = await db.update(chapters).set(updateData).where(eq(chapters.id, chapter.id));
        console.log('Update result:', result);
        
        // Automatically regenerate embeddings for the updated chapter
        // TEMPORARILY DISABLED - causing memory issues and UI freezing
        /*
        try {
          const response = await fetch(`http://localhost:8000/embeddings/generate/${chapter.id}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings updated for chapter:', chapter.id);
          } else {
            console.warn('Failed to update embeddings for chapter:', chapter.id);
          }
        } catch (error) {
          console.warn('Could not update embeddings (AI service may not be running):', error);
        }
        */
        
        return { success: true };
      } catch (error) {
        console.error('Error updating chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('reorder-chapters', async (event, chapterIds: string[]) => {
      try {
        // Update the order of chapters using batch update
        // We'll use a simple approach: update each chapter with its new position
        const updatePromises = chapterIds.map((id, index) => {
          return db.update(chapters).set({
            order: index
          }).where(eq(chapters.id, id));
        });
        
        await Promise.all(updatePromises);
        
        return { success: true };
      } catch (error) {
        console.error('Error reordering chapters:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-chapter-dynamic', async (event, payload) => {
      try {
        // Import the smartInsert function
        const { smartInsert } = await import('./lib/markdownSync');
        
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          // Create default markdown if none exists
          markdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
        }
        
        // Check if payload is in section/content format or full SyncPayload format
        let syncedMarkdown: string;
        if (payload.section && payload.content) {
          // Handle section/content format - insert content directly into specified section
          syncedMarkdown = insertContentIntoSection(markdown, payload.section, payload.content);
        } else {
          // Handle full SyncPayload format
          syncedMarkdown = smartInsert(markdown, payload);
        }
        
        // Save updated markdown
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error syncing chapter dynamically:', error);
        throw error;
      }
    });

    // Safe VM sync IPC handlers
    ipcMain.handle('sync-to-vm', async () => {
      try {
        console.log('Starting safe sync to VM...');
        const result = await syncQueue.add(() => safeDatabaseSync('to-vm'));
        
        if (result.success) {
          return { success: true, message: result.message, output: result.output };
        } else {
          throw new Error(result.error);
        }
      } catch (error) {
        console.error('Safe VM sync failed:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-from-vm', async () => {
      try {
        console.log('Starting safe sync from VM...');
        const result = await syncQueue.add(() => safeDatabaseSync('from-vm'));
        
        if (result.success) {
          return { success: true, message: result.message, output: result.output };
        } else {
          throw new Error(result.error);
        }
      } catch (error) {
        console.error('Safe VM sync failed:', error);
        throw error;
      }
    });

    // Manual backup cleanup handler
    ipcMain.handle('cleanup-backups', async () => {
      try {
        console.log('Starting manual backup cleanup...');
        const fs = require('fs');
        
        // Get count before cleanup
        const beforeCount = fs.readdirSync('.')
          .filter(file => 
            (file.startsWith('writegeist_backup_') || 
             file.startsWith('writegeist_temp_') || 
             file.startsWith('writegeist_corrupted_') ||
             file.startsWith('writegeist_from_vm') ||
             file.startsWith('writegeist_latest')) && 
            file.endsWith('.db')
          ).length;
        
        cleanupOldBackups();
        
        // Get count after cleanup
        const afterCount = fs.readdirSync('.')
          .filter(file => 
            (file.startsWith('writegeist_backup_') || 
             file.startsWith('writegeist_temp_') || 
             file.startsWith('writegeist_corrupted_') ||
             file.startsWith('writegeist_from_vm') ||
             file.startsWith('writegeist_latest')) && 
            file.endsWith('.db')
          ).length;
        
        const deletedCount = beforeCount - afterCount;
        
        return { 
          success: true, 
          message: `Cleanup completed. Deleted ${deletedCount} old backup files.`,
          beforeCount,
          afterCount,
          deletedCount
        };
      } catch (error) {
        console.error('Manual backup cleanup failed:', error);
        throw error;
      }
    });

    // System health check IPC handler
    ipcMain.handle('system-health-check', async () => {
      try {
        const healthStatus = await performSystemHealthCheck();
        return { success: true, healthStatus };
      } catch (error) {
        console.error('System health check IPC failed:', error);
        return { success: false, error: error.message };
      }
    });

    // Audio IPC handlers
    ipcMain.handle('generate-audio', async (event, chapterId) => {
      try {
        const response = await fetch('http://localhost:8000/audio/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chapter_id: chapterId }),
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        return result;
      } catch (error) {
        console.error('Error generating audio:', error);
        throw error;
      }
    });
    
    ipcMain.handle('get-audio-status', async (event, chapterId) => {
      try {
        const response = await fetch(`http://localhost:8000/audio/status/${chapterId}`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        return result;
      } catch (error) {
        console.error('Error getting audio status:', error);
        throw error;
      }
    });
    
    ipcMain.handle('get-all-audio', async () => {
      try {
        const { chapterAudio } = require('./db');
        const result = await db.select().from(chapterAudio).orderBy(chapterAudio.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting all audio:', error);
        return [];
      }
    });

    // Start database monitoring after initialization
    const dbPath = path.join(process.cwd(), 'writegeist.db');
    // We'll start monitoring once the window is created
    
    // Create window after database is initialized and IPC handlers are registered
    createWindow();
    
    // Start webhook server after window is created
    if (!webhookServerStarted && globalMainWindow) {
      startWebhookServer(globalMainWindow);
      webhookServerStarted = true;
    }
  }).catch(console.error);
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Clean up the API backend process when the app is quitting
// Cleanup function for safe shutdown
const performCleanupOnShutdown = async () => {
  console.log('Performing cleanup on shutdown...');
  
  try {
    // Stop any ongoing sync operations
    if (syncMutex) {
      console.log('Warning: Sync operation in progress during shutdown');
    }
    
    // Close database file watcher
    if (dbWatcher) {
      dbWatcher.close();
      console.log('Database watcher closed');
    }
    
    // Create final backup
    const backupPath = createSafeBackup('shutdown');
    if (backupPath) {
      console.log('Final backup created on shutdown');
    }
    
    console.log('Cleanup completed successfully');
  } catch (error) {
    console.error('Error during cleanup:', error);
  }
};

app.on('will-quit', () => {
  if (apiProcess) {
    console.log('Stopping API backend...');
    apiProcess.kill();
    apiProcess = null;
  }
  
  if (webhookServer) {
    console.log('Stopping webhook server...');
    webhookServer.close();
    webhookServer = null;
  }
  
  if (audioServer) {
    console.log('Stopping audio server...');
    audioServer.close();
    audioServer = null;
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
