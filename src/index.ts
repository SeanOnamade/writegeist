import { app, BrowserWindow, ipcMain } from 'electron';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Configure CSP to allow localhost connections
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' http://127.0.0.1:8000 http://localhost:8000; script-src 'self' 'unsafe-inline' 'unsafe-eval';"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Initialize database
  import('./db').then(({ db, chapters, projectPages }) => {
    const { eq } = require('drizzle-orm');
    console.log('Database initialized');
    
    // Set up IPC handlers
    ipcMain.handle('save-chapter', async (event, chapter) => {
      try {
        await db.insert(chapters).values({
          id: chapter.id || `chapter_${Date.now()}`,
          title: chapter.title,
          text: chapter.text,
          characters: JSON.stringify(chapter.characters || []),
          locations: JSON.stringify(chapter.locations || []),
          pov: JSON.stringify(chapter.pov || []),
        });
        return { success: true };
      } catch (error) {
        console.error('Error saving chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('get-chapters', async () => {
      try {
        const result = await db.select().from(chapters).orderBy(chapters.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting chapters:', error);
        return [];
      }
    });

    ipcMain.handle('delete-chapter', async (event, id) => {
      try {
        await db.delete(chapters).where(eq(chapters.id, id));
        return { success: true };
      } catch (error) {
        console.error('Error deleting chapter:', error);
        throw error;
      }
    });

    // Project document handlers
    ipcMain.handle('get-project-doc', async () => {
      try {
        const result = await db.select().from(projectPages).limit(1);
        if (result.length > 0) {
          return result[0].markdown;
        } else {
          // Insert default markdown if none exists
          const defaultMarkdown = `# My Project

## Ideas/Notes

## Setting

## Full Outline

## Characters`;
          await db.insert(projectPages).values({
            id: 1,
            markdown: defaultMarkdown,
          });
          return defaultMarkdown;
        }
      } catch (error) {
        console.error('Error getting project document:', error);
        throw error;
      }
    });

    ipcMain.handle('save-project-doc', async (event, markdown) => {
      try {
        // Try to update first, if no rows affected, insert
        const result = await db.select().from(projectPages).where(eq(projectPages.id, 1));
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown });
        }
        return { success: true };
      } catch (error) {
        console.error('Error saving project document:', error);
        throw error;
      }
    });

    ipcMain.handle('append-characters', async (event, chars) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Characters section
        const charactersMatch = markdown.match(/^## Characters\s*$/m);
        if (!charactersMatch) {
          return { success: false, error: 'Characters section not found' };
        }
        
        // Get the position after the Characters heading
        const charactersIndex = charactersMatch.index + charactersMatch[0].length;
        
        // Extract existing characters from bullet list
        const afterCharacters = markdown.substring(charactersIndex);
        const existingCharacters = new Set<string>();
        
        // Match bullet points and extract character names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterCharacters)) !== null) {
          // Extract character name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingCharacters.add(name);
        }
        
        // Filter out characters that already exist, with better name matching
        const newCharacters = chars.filter((char: string) => {
          const charName = char.split("(")[0].trim();
          // Check if bullet already begins with "* " + name
          const existingBulletPattern = `* ${charName}`;
          return !Array.from(existingCharacters).some(existing => 
            existing.toLowerCase() === charName.toLowerCase() ||
            afterCharacters.includes(existingBulletPattern)
          );
        });
        
        if (newCharacters.length === 0) {
          return { success: true, message: 'No new characters to add' };
        }
        
        // Find the end of the Characters section (next ## heading or end of document)
        const nextSectionMatch = afterCharacters.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? charactersIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new characters using asterisk bullets
        const characterBullets = newCharacters.map((char: string) => `* ${char}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + characterBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newCharacters };
      } catch (error) {
        console.error('Error appending characters:', error);
        return { success: false, error: 'Failed to append characters' };
      }
    });

    ipcMain.handle('update-chapter', async (event, chapter) => {
      try {
        // Helper function to ensure proper JSON string format
        const ensureJsonString = (field: any) => {
          if (typeof field === 'string') {
            try {
              // If it's already a JSON string, parse it first then re-stringify
              const parsed = JSON.parse(field);
              return JSON.stringify(parsed);
            } catch {
              // If it's not valid JSON, treat as empty array
              return JSON.stringify([]);
            }
          } else if (Array.isArray(field)) {
            return JSON.stringify(field);
          } else {
            return JSON.stringify([]);
          }
        };

        await db.update(chapters).set({
          title: chapter.title,
          text: chapter.text,
          characters: ensureJsonString(chapter.characters),
          locations: ensureJsonString(chapter.locations),
          pov: ensureJsonString(chapter.pov),
        }).where(eq(chapters.id, chapter.id));
        return { success: true };
      } catch (error) {
        console.error('Error updating chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-chapter-dynamic', async (event, payload) => {
      try {
        // Import the smartInsert function
        const { smartInsert } = await import('./lib/markdownSync');
        
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          // Create default markdown if none exists
          markdown = `# My Project

## Ideas/Notes

## Setting

## Full Outline

## Characters`;
        }
        
        // Apply smart insertion
        const syncedMarkdown = smartInsert(markdown, payload);
        
        // Save updated markdown
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error syncing chapter dynamically:', error);
        throw error;
      }
    });
  }).catch(console.error);
  
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
